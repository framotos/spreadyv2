{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/client.ts","../src/services.ts"],"sourcesContent":["export * from './types';\nexport * from './client';\nexport * from './services'; ","// Re-export types from the types package\nexport {\n  DatasetType,\n  AskRequest,\n  AskResponse,\n  BackendSession,\n  BackendMessage,\n  Session,\n  Message\n} from '@neurofinance/types'; ","'use client';\n\nimport axios, { AxiosInstance, InternalAxiosRequestConfig } from 'axios';\n\n// Default API base URL\nconst DEFAULT_API_BASE_URL = 'http://localhost:8000';\n\ninterface ApiClientConfig {\n  baseUrl?: string;\n  getAccessToken?: () => Promise<string | null>;\n}\n\n// Create an Axios instance with base configuration\nexport const createApiClient = (config: ApiClientConfig = {}): AxiosInstance => {\n  const baseURL = config.baseUrl || DEFAULT_API_BASE_URL;\n  \n  const client = axios.create({\n    baseURL,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  // Request interceptor to add the auth token\n  if (config.getAccessToken) {\n    client.interceptors.request.use(async (axiosConfig: InternalAxiosRequestConfig) => {\n      try {\n        const token = await config.getAccessToken?.();\n        \n        if (token) {\n          axiosConfig.headers.Authorization = `Bearer ${token}`;\n        }\n        \n        return axiosConfig;\n      } catch (error) {\n        console.error('Error accessing auth token:', error);\n        return axiosConfig;\n      }\n    });\n  }\n\n  return client;\n};\n\n// Create a public client without auth\nexport const createPublicApiClient = (baseUrl?: string): AxiosInstance => {\n  return axios.create({\n    baseURL: baseUrl || DEFAULT_API_BASE_URL,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n}; ","'use client';\n\nimport axios, { AxiosInstance, AxiosError } from 'axios';\nimport { \n  AskRequest, \n  AskResponse, \n  Session, \n  BackendSession, \n  Message, \n  BackendMessage \n} from './types';\n\n// Cache functionality\nlet sessionsCache: Session[] | null = null;\nlet sessionsCacheTime: number = 0;\nconst CACHE_EXPIRY_MS = 5000; // 5 seconds cache validity\n\n// Cache invalidation\nconst invalidateCache = () => {\n  sessionsCache = null;\n};\n\nexport class ApiService {\n  private client: AxiosInstance;\n  \n  constructor(apiClient: AxiosInstance) {\n    this.client = apiClient;\n  }\n\n  /**\n   * Updates or creates a session\n   */\n  async updateSession(\n    sessionId: string, \n    htmlFiles: string[], \n    outputFolder: string,\n    lastMessage: string\n  ): Promise<Session> {\n    try {\n      const response = await this.client.put<BackendSession>(`/sessions/${sessionId}`, {\n        html_files: htmlFiles,\n        output_folder: outputFolder,\n        last_message: lastMessage\n      });\n      \n      const updatedSession: Session = {\n        id: response.data.id,\n        lastMessage: response.data.last_message || 'Neue Konversation',\n        timestamp: response.data.timestamp || new Date().toISOString(),\n        htmlFiles: response.data.html_files || [],\n        outputFolder: response.data.output_folder || outputFolder\n      };\n      \n      invalidateCache();\n      return updatedSession;\n    } catch (error: unknown) {\n      console.error('Error updating session:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieves messages for a specific session\n   */\n  async getSessionMessages(sessionId: string): Promise<Message[]> {\n    try {\n      const response = await this.client.get<Message[]>(`/sessions/${sessionId}/messages`);\n      \n      // Ensure response conforms to Message[] type\n      const messages: Message[] = response.data.map((msg: any) => ({\n        id: msg.id,\n        userId: msg.userId,\n        content: msg.content,\n        sender: msg.sender,\n        htmlFiles: msg.htmlFiles || [],\n        outputFolder: msg.outputFolder,\n        timestamp: msg.timestamp\n      }));\n      \n      return messages;\n    } catch (error: unknown) {\n      console.error('Error retrieving session messages:', error);\n      if (axios.isAxiosError(error)) {\n        const axiosError = error as AxiosError;\n        console.error('Axios error details:', axiosError.response?.data);\n        throw new Error(\n          (axiosError.response?.data as any)?.detail || 'Error retrieving messages'\n        );\n      } else {\n        throw new Error('Unknown error retrieving messages');\n      }\n    }\n  }\n\n  /**\n   * Asks a question to the backend agent for a specific session\n   */\n  async askQuestion(\n    sessionId: string, \n    question: string\n  ): Promise<AskResponse> {\n    const payload: AskRequest = {\n      session_id: sessionId,\n      question,\n    };\n    \n    try {\n      const response = await this.client.post<AskResponse>('/ask', payload);\n      return response.data;\n    } catch (error: unknown) {\n      console.error('Error calling /ask endpoint:', error);\n      if (axios.isAxiosError(error)) {\n        const axiosError = error as AxiosError;\n        console.error('Axios error details:', axiosError.response?.data);\n        throw new Error(\n          (axiosError.response?.data as any)?.detail || 'Error querying the agent'\n        );\n      } else {\n        throw new Error('Unknown error querying the agent');\n      }\n    }\n  }\n\n  /**\n   * Retrieves all sessions for the current user\n   */\n  async getSessions(): Promise<Session[]> {\n    // Cache check\n    const now = Date.now();\n    if (sessionsCache && now - sessionsCacheTime < CACHE_EXPIRY_MS) {\n      return sessionsCache;\n    }\n    \n    try {\n      const response = await this.client.get<BackendSession[]>('/sessions');\n      \n      const transformedSessions = response.data.map((session: BackendSession) => ({\n        id: session.id,\n        userId: session.user_id,\n        lastMessage: session.last_message || 'Neue Konversation',\n        timestamp: session.timestamp || new Date().toISOString(),\n        htmlFiles: session.html_files || [],\n        outputFolder: session.output_folder\n      }));\n      \n      sessionsCache = transformedSessions;\n      sessionsCacheTime = now;\n      \n      return transformedSessions;\n    } catch (error: unknown) {\n      console.error('Error retrieving sessions:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Creates a new session\n   */\n  async createSession(sessionId: string): Promise<Session> {\n    try {\n      const outputFolder = `user_question_output_${sessionId.substring(0, 4)}`;\n      \n      const updatedSession = await this.updateSession(\n        sessionId,\n        [],\n        outputFolder,\n        'Neue Konversation'\n      );\n      \n      return updatedSession;\n    } catch (error: unknown) {\n      console.error('Error creating session:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Adds a message to a session\n   */\n  async addMessage(\n    sessionId: string, \n    content: string, \n    sender: 'user' | 'assistant'\n  ): Promise<BackendMessage> {\n    const payload = {\n      content,\n      sender,\n    };\n    \n    try {\n      const response = await this.client.post<BackendMessage>(\n        `/sessions/${sessionId}/messages`,\n        payload\n      );\n      \n      return response.data;\n    } catch (error: unknown) {\n      console.error('Error adding message:', error);\n      if (axios.isAxiosError(error)) {\n        const axiosError = error as AxiosError;\n        console.error('Axios error details:', axiosError.response?.data);\n        throw new Error(\n          (axiosError.response?.data as any)?.detail || 'Error adding message'\n        );\n      } else {\n        throw new Error('Unknown error adding message');\n      }\n    }\n  }\n  \n  /**\n   * Health check function\n   */\n  async checkHealth(): Promise<any> {\n    try {\n      const response = await this.client.get('/health');\n      return response.data;\n    } catch (error: unknown) {\n      console.error('Health check error:', error);\n      throw error;\n    }\n  }\n} "],"mappings":"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","names":["axios","import_axios","axios"]}